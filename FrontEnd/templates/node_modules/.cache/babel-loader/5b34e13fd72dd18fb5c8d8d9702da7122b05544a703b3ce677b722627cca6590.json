{"ast":null,"code":"var e = function () {\n    return (e = Object.assign || function (e) {\n      for (var t, r = 1, s = arguments.length; r < s; r++) for (var a in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);\n      return e;\n    }).apply(this, arguments);\n  },\n  t = {\n    kebab: /-(\\w)/g,\n    styleProp: /:(.*)/,\n    styleList: /;(?![^(]*\\))/g\n  };\nfunction r(e, t) {\n  return t ? t.toUpperCase() : \"\";\n}\nfunction s(e) {\n  for (var s, a = {}, c = 0, o = e.split(t.styleList); c < o.length; c++) {\n    var n = o[c].split(t.styleProp),\n      i = n[0],\n      l = n[1];\n    (i = i.trim()) && (\"string\" == typeof l && (l = l.trim()), a[(s = i, s.replace(t.kebab, r))] = l);\n  }\n  return a;\n}\nfunction a() {\n  for (var t, r, a = {}, c = arguments.length; c--;) for (var o = 0, n = Object.keys(arguments[c]); o < n.length; o++) switch (t = n[o]) {\n    case \"class\":\n    case \"style\":\n    case \"directives\":\n      if (Array.isArray(a[t]) || (a[t] = []), \"style\" === t) {\n        var i = void 0;\n        i = Array.isArray(arguments[c].style) ? arguments[c].style : [arguments[c].style];\n        for (var l = 0; l < i.length; l++) {\n          var y = i[l];\n          \"string\" == typeof y && (i[l] = s(y));\n        }\n        arguments[c].style = i;\n      }\n      a[t] = a[t].concat(arguments[c][t]);\n      break;\n    case \"staticClass\":\n      if (!arguments[c][t]) break;\n      void 0 === a[t] && (a[t] = \"\"), a[t] && (a[t] += \" \"), a[t] += arguments[c][t].trim();\n      break;\n    case \"on\":\n    case \"nativeOn\":\n      a[t] || (a[t] = {});\n      for (var p = 0, f = Object.keys(arguments[c][t] || {}); p < f.length; p++) r = f[p], a[t][r] ? a[t][r] = [].concat(a[t][r], arguments[c][t][r]) : a[t][r] = arguments[c][t][r];\n      break;\n    case \"attrs\":\n    case \"props\":\n    case \"domProps\":\n    case \"scopedSlots\":\n    case \"staticStyle\":\n    case \"hook\":\n    case \"transition\":\n      a[t] || (a[t] = {}), a[t] = e({}, arguments[c][t], a[t]);\n      break;\n    case \"slot\":\n    case \"key\":\n    case \"ref\":\n    case \"tag\":\n    case \"show\":\n    case \"keepAlive\":\n    default:\n      a[t] || (a[t] = arguments[c][t]);\n  }\n  return a;\n}\nexport { a as mergeData };","map":{"version":3,"names":["t","kebab","styleProp","styleList","r","e","toUpperCase","s","a","c","o","split","length","n","i","l","trim","replace","arguments","Object","keys","Array","isArray","style","y","concat","p","f","mergeData"],"sources":["../src/index.ts"],"sourcesContent":["import { VNodeData } from \"vue\";\n\nconst pattern = {\n  kebab: /-(\\w)/g,\n  styleProp: /:(.*)/,\n\tstyleList: /;(?![^(]*\\))/g,\n} as const;\n\nfunction camelReplace(_substr: string, match: string) {\n  return match ? match.toUpperCase() : \"\";\n}\n\nfunction camelCase(str: string) {\n  return str.replace(pattern.kebab, camelReplace);\n}\n\nfunction parseStyle(style: string) {\n  let styleMap: Record<string, any> = {};\n\n  for (let s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n    if (!key) {\n      continue;\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === \"string\") {\n      val = val.trim();\n    }\n    styleMap[camelCase(key)] = val;\n  }\n\n  return styleMap;\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nfunction mergeData(...vNodeData: VNodeData[]): VNodeData;\nfunction mergeData(): VNodeData {\n  let mergeTarget: VNodeData & Record<string, any> = {};\n  let i: number = arguments.length;\n  let prop: string;\n  let event: string;\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case \"class\":\n        case \"style\":\n        case \"directives\":\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = [];\n          }\n\n          if (prop === \"style\") {\n            let style: any[];\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style;\n            } else {\n              style = [arguments[i].style];\n            }\n            for (let j = 0; j < style.length; j++) {\n              let s = style[j];\n              if (typeof s === \"string\") {\n                style[j] = parseStyle(s);\n              }\n            }\n            arguments[i].style = style;\n          }\n\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop]);\n          break;\n        // Space delimited string concatenation strategy\n        case \"staticClass\":\n          if (!arguments[i][prop]) {\n            break;\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = \"\";\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += \" \";\n          }\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case \"on\":\n        case \"nativeOn\":\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (mergeTarget[prop][event]) {\n              // Insert current iteration data in beginning of merged array.\n              mergeTarget[prop][event] = [].concat(\n                mergeTarget[prop][event],\n                arguments[i][prop][event]\n              );\n            } else {\n              // Straight assign.\n              mergeTarget[prop][event] = arguments[i][prop][event];\n            }\n          }\n          break;\n        // Object merge strategy\n        case \"attrs\":\n        case \"props\":\n        case \"domProps\":\n        case \"scopedSlots\":\n        case \"staticStyle\":\n        case \"hook\":\n        case \"transition\":\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] };\n          break;\n        // Reassignment strategy (no merge)\n        case \"slot\":\n        case \"key\":\n        case \"ref\":\n        case \"tag\":\n        case \"show\":\n        case \"keepAlive\":\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n      }\n    }\n  }\n\n  return mergeTarget;\n}\n\nexport { mergeData };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}